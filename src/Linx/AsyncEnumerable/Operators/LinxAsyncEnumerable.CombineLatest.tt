<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
namespace Linx.AsyncEnumerable
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Runtime.CompilerServices;
    using System.Threading;
    using System.Threading.Tasks;
    using TaskSources;

    partial class LinxAsyncEnumerable
    {
<#
const int min = 2;
const int max = 8;
foreach(var n in Enumerable.Range(min, max - min + 1))
{
    var indexes = Enumerable.Range(1, n);
    var names = indexes
        .Select(i => new 
        {
            GenArg = "T" + i,
            Source = "source" + i,
            Value = "Value" + i
        })
        .ToList();
    var genArgs = $"<{string.Join(", ", names.Select(x => x.GenArg))}, TResult>";
#>
        /// <summary>
        /// Merges differently typed sequences into one.
        /// </summary>
        public static IAsyncEnumerable<TResult> CombineLatest<#= genArgs #>(this
<# foreach(var x in names) { #>
            IAsyncEnumerable<<#= x.GenArg #>> <#= x.Source #>, 
<# } #>
            Func<#= genArgs #> resultSelector) 
            => new CombineLatestEnumerable<#= genArgs #>(<#= string.Join(", ", names.Select(x => x.Source)) #>, resultSelector);

        private sealed class CombineLatestEnumerable<#= genArgs #> : IAsyncEnumerable<TResult>
        {
<# foreach(var x in names) { #>
            private readonly IAsyncEnumerable<<#= x.GenArg #>> _<#= x.Source #>;
<# } #>
            private readonly Func<#= genArgs #> _resultSelector;

            public CombineLatestEnumerable(
<# foreach(var x in names) { #>
                IAsyncEnumerable<<#= x.GenArg #>> <#= x.Source #>, 
<# } #>
                Func<#= genArgs #> resultSelector)
            {
                _source1 = source1 ?? throw new ArgumentNullException(nameof(source1));
                _source2 = source2 ?? throw new ArgumentNullException(nameof(source2));
                _resultSelector = resultSelector ?? throw new ArgumentNullException(nameof(resultSelector));
            }

            public IAsyncEnumerator<TResult> GetAsyncEnumerator(CancellationToken token) => new Enumerator(this, token);

            private sealed class Enumerator : IAsyncEnumerator<TResult>
            {
                private const int _sInitial = 0;
                private const int _sAccepting = 1;
                private const int _sEmitting = 2;
                private const int _sCompleted = 3;

                private sealed class Context
                {
                    private readonly CancellationTokenSource _cts = new CancellationTokenSource();

                    public int Unassigned = <#= n #>;
                    public int Active = <#= n #>;
                    public bool HasNext;
<# foreach(var x in names) { #>
                    public <#= x.GenArg #> <#= x.Value #>;
<# } #>

                    public CancellationToken Token => _cts.Token;

                    public void TryCancel()
                    {
                        try { _cts.Cancel(); }
                        catch { /**/ }
                    }

                    public TResult GetResult(Func<#= genArgs #> resultSelector) => resultSelector(<#= string.Join(", ", names.Select(x => x.Value)) #>);
                }

                private readonly CombineLatestEnumerable<#= genArgs #> _enumerable;
                private readonly ManualResetValueTaskSource<bool> _tsMoveNext = new ManualResetValueTaskSource<bool>();
                private AsyncTaskMethodBuilder _atmbDisposed = new AsyncTaskMethodBuilder();
                private CancellationTokenRegistration _ctr;
                private Context _context = new Context();
                private int _state;
                private Exception _error;

                public TResult Current { get; private set; }

                public Enumerator(CombineLatestEnumerable<#= genArgs #> enumerable, CancellationToken token)
                {
                    _enumerable = enumerable;
                    if (token.CanBeCanceled) _ctr = token.Register(() => OnError(new OperationCanceledException(token)));
                }

                public ValueTask<bool> MoveNextAsync()
                {
                    _tsMoveNext.Reset();

                    var state = Atomic.Lock(ref _state);
                    switch (state)
                    {
                        case _sInitial:
                            _state = _sAccepting;
<# foreach(var x in names) { #>
                            Subscribe(_enumerable._<#= x.Source #>, (c, v) => c.<#= x.Value #> = v);
<# } #>
                            break;

                        case _sEmitting:
                            if (_error != null)
                            {
                                Current = default;
                                _state = _sEmitting;
                                _tsMoveNext.SetException(_error);
                            }
                            else if (_context.HasNext)
                            {
                                try
                                {
                                    Current = _context.GetResult(_enumerable._resultSelector);
                                    _context.HasNext = false;
                                    _state = _sEmitting;
                                }
                                catch (Exception ex)
                                {
                                    _error = ex;
                                    Current = default;
                                    _state = _sEmitting;
                                    _ctr.Dispose();
                                    _context.TryCancel();
                                }
                                _tsMoveNext.SetExceptionOrResult(_error, true);
                            }
                            else
                                _state = _sAccepting;
                            break;

                        case _sCompleted:
                            if (_context != null)
                            {
                                Debug.Assert(_error == null && _context.HasNext);
                                try
                                {
                                    Current = _context.GetResult(_enumerable._resultSelector);
                                }
                                catch (Exception ex)
                                {
                                    Current = default;
                                    _error = ex;
                                }

                                _context = null;
                                _state = _sCompleted;
                                _ctr.Dispose();
                                _atmbDisposed.SetResult();
                                _tsMoveNext.SetExceptionOrResult(_error, true);
                            }
                            else
                            {
                                Current = default;
                                _state = _sCompleted;
                                _tsMoveNext.SetExceptionOrResult(_error, false);
                            }
                            break;

                        default: // Accepting???
                            _state = state;
                            throw new Exception(state + "???");
                    }

                    return _tsMoveNext.Task;
                }

                public ValueTask DisposeAsync()
                {
                    OnError(AsyncEnumeratorDisposedException.Instance);
                    return new ValueTask(_atmbDisposed.Task);
                }

                private void OnError(Exception error)
                {
                    Debug.Assert(error != null);

                    var state = Atomic.Lock(ref _state);
                    if (_error != null)
                    {
                        _state = state;
                        return;
                    }

                    switch (state)
                    {
                        case _sInitial:
                            _error = error;
                            _context = null;
                            _state = _sCompleted;
                            _ctr.Dispose();
                            _atmbDisposed.SetResult();
                            break;

                        case _sAccepting:
                            _error = error;
                            Current = default;
                            _state = _sEmitting;
                            _ctr.Dispose();
                            _context.TryCancel();
                            _tsMoveNext.SetException(error);
                            break;

                        case _sEmitting:
                            _error = error;
                            _state = _sEmitting;
                            _ctr.Dispose();
                            _context.TryCancel();
                            break;

                        case _sCompleted:
                            var ctx = Linx.Clear(ref _context);
                            if (ctx == null)
                                _state = _sCompleted;
                            else
                            {
                                _error = error;
                                _state = _sCompleted;
                                _ctr.Dispose();
                                _atmbDisposed.SetResult();
                            }
                            break;

                        default:
                            _state = state;
                            throw new Exception(state + "???");
                    }
                }

                private void OnCompleted()
                {
                    var state = Atomic.Lock(ref _state);
                    if (--_context.Active > 0)
                    {
                        _state = state;
                        return;
                    }

                    var ctx = _context;
                    switch (state)
                    {
                        case _sAccepting:
                            Debug.Assert(_error == null && !ctx.HasNext);
                            _context = null;
                            Current = default;
                            _state = _sCompleted;
                            _ctr.Dispose();
                            ctx.TryCancel();
                            _atmbDisposed.SetResult();
                            _tsMoveNext.SetResult(false);
                            break;

                        case _sEmitting:
                            if (_error != null)
                            {
                                _context = null;
                                _state = _sCompleted;
                                _atmbDisposed.SetResult();
                            }
                            else if (ctx.HasNext)
                            {
                                _state = _sCompleted;
                                ctx.TryCancel();
                            }
                            else
                            {
                                _context = null;
                                _state = _sCompleted;
                                _ctr.Dispose();
                                ctx.TryCancel();
                                _atmbDisposed.SetResult();
                            }
                            break;

                        default: // initial, completed???
                            _state = state;
                            throw new Exception(state + "???");
                    }
                }

                private async void Subscribe<T>(IAsyncEnumerable<T> source, Action<Context, T> setValue)
                {
                    try
                    {
                        _context.Token.ThrowIfCancellationRequested();
                        var ae = source.WithCancellation(_context.Token).ConfigureAwait(false).GetAsyncEnumerator();
                        try
                        {
                            var any = false;
                            while (await ae.MoveNextAsync())
                            {
                                _context.Token.ThrowIfCancellationRequested();
                                var current = ae.Current;

                                var state = Atomic.Lock(ref _state);

                                if (!Linx.Exchange(ref any, true))
                                    _context.Unassigned--;

                                setValue(_context, current);
                                if (_context.Unassigned > 0)
                                {
                                    _state = state;
                                    continue;
                                }

                                switch (state)
                                {
                                    case _sAccepting:
                                        try { Current = _context.GetResult(_enumerable._resultSelector); }
                                        catch
                                        {
                                            _state = _sAccepting;
                                            throw;
                                        }

                                        _state = _sEmitting;
                                        _tsMoveNext.SetResult(true);
                                        break;

                                    case _sEmitting:
                                        _context.HasNext = true;
                                        _state = _sEmitting;
                                        break;

                                    default: // initial, completed???
                                        _state = state;
                                        throw new Exception(state + "???");
                                }
                            }
                        }
                        finally { await ae.DisposeAsync(); }
                    }
                    catch (Exception ex) { OnError(ex); }
                    finally { OnCompleted(); }
                }
            }
        }

<# } #>
    }
}